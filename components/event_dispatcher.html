<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <title>Компонент EventDispatcher &mdash; Symfony Framework Documentation  documentation</title>
    
    <link rel="stylesheet" href="../_static/" type="text/css">
    <link rel="stylesheet" href="..\_static\pygments.css" type="text/css">
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <link rel="top" title="Symfony Framework Documentation  documentation" href="..\index.html">
    <link rel="up" title="The Components" href="index.html">
    <link rel="next" title="The ExpressionLanguage Component" href="expression_language.html">
    <link rel="prev" title="Как настроить поведение метода, не используя наследование" href="../event_dispatcher/method_behavior-ru.html">

<link rel="stylesheet" href="..\_assets\app.css?v=8d6d457a0820d7c245bddae16bfd4c75">
<script src="..\_assets\manifest.js?v=d41d8cd98f00b204e980"></script>
<script src="..\_assets\app.js?v=900984040c7cb4dca514"></script>
<style>
    .header__top .container {
        overflow: hidden;
        padding-top: 10px;
        padding-bottom: 10px;
    }
    .header__top .header__logo {
        float: left;
    }
    .header__top .header__support {
        float: right;
    }

    .highlight .k, .highlight .gh, .highlight .gp,
    .highlight .gu, .highlight .kc, .highlight .kd,
    .highlight .kn, .highlight .kr, .highlight .nc,
    .highlight .nd, .highlight .ni, .highlight .nl,
    .highlight .nn, .highlight .nt, .highlight .ow,
    .highlight .se { font-weight: normal; }

    .highlight .c, .highlight .cm, .highlight .c1,
    .highlight .sd, .highlight .si { font-style: normal; }

    .doc { background: none; }
    #demo-warning {
        border: 3px dashed #c00;
        padding: 10px;
        margin-bottom: 30px;
    }
    #demo-warning h4 { font-size: 1.7em;font-weight: bold; }
    #demo-warning p { margin-bottom: 0; }
</style>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-107764519-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-107764519-1');
</script>

<!-- Facebook Pixel Code -->
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
        n.callMethod.apply(n,arguments):n.queue.push(arguments)};
        if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
        n.queue=[];t=b.createElement(e);t.async=!0;
        t.src=v;s=b.getElementsByTagName(e)[0];
        s.parentNode.insertBefore(t,s)}(window, document,'script',
        'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '250281335689441');
    fbq('track', 'PageView');
</script>
<img height="1" width="1" style="display:none" src="https://www.facebook.com/tr?id=250281335689441&ev=PageView&noscript=1">
<!-- End Facebook Pixel Code -->

<script type="text/javascript">!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="https://vk.com/js/api/openapi.js?159",t.onload=function(){VK.Retargeting.Init("VK-RTRG-279161-8p6Jv"),VK.Retargeting.Hit()},document.head.appendChild(t)}();</script><img src="https://vk.com/rtrg?p=VK-RTRG-279161-8p6Jv" style="position:fixed; left:-999px;" alt="">


  </head>
  <body role="document">

<body class="components doc_article doc">

<header>
    <section class="header__top">
        <div class="container">
            <div class="header__logo">
                <a href="..\..\..\index.html">
                    <img src="..\..\..\_images\header-logo.svg" alt="Symfony.com.ua logo">
                </a>
            </div>
            <div class="header__support hidden-xs">
                <a href="http://playtini.ua/" title="Компания Playtini">
                    <img height="69" src="..\..\..\_images\support.png" alt="Symfony is a SensioLabs product">
                </a>
            </div>
        </div>
    </section>
</header>

<div class="container"><div id="page-content">
    <div class="row">
        <div id="sidebar" class="col-sm-3">
            <div id="sidebar-content"><div class="submenu">
    
    
    <ul class="list_submenu list-unstyled">
    
        <li class="first">
            <a href="..\index.html">Главная</a>
        </li>
    
        <li>
            <a href="index.html">Компоненты</a>
        </li>
    
        <li>
            <a href="..\best_practices\index.html">Лучшие практики</a>
        </li>
    
        <li>
            <a href="..\quick_tour\index.html">Быстрый старт</a>
        </li>
    
        <li>
            <a href="..\reference\index.html">Справочник</a>
        </li>
    
        <li>
            <a href="..\genindex.html">Индекс</a>
        </li>
    
        <li>
            <a href="..\contributing\index.html">Участие</a>
        </li>
    
    </ul>
</div>

                <div class="toc"> 
    <h4>Содержание</h4>
    <div class="toc-content">
        <ul>
<li><a class="reference internal" href="#">Компонент EventDispatcher</a><ul>
<li><a class="reference internal" href="#id1">Вступление</a></li>
<li><a class="reference internal" href="#index-1">Установка</a></li>
<li><a class="reference internal" href="#id3">Применение</a><ul>
<li><a class="reference internal" href="#id4">События</a><ul>
<li><a class="reference internal" href="#index-2">Соглашения именования</a></li>
<li><a class="reference internal" href="#index-3">Именя и объекты событий</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">Диспетчер</a></li>
<li><a class="reference internal" href="#index-4">Соединение слушателей</a></li>
<li><a class="reference internal" href="#index-5">Создание и запуск события</a><ul>
<li><a class="reference internal" href="#creating-an-event-object-ru">Создание класса событий</a></li>
<li><a class="reference internal" href="#id11">Запустите событие</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-dispatcher-using-event-subscribers-ru">Использование подписчиков событий</a></li>
<li><a class="reference internal" href="#event-dispatcher-event-propagation-ru">Остановка потока / распространения событий</a></li>
<li><a class="reference internal" href="#event-dispatcher-dispatcher-aware-events-ru">События и слушатели, знающие об EventDispatcher</a></li>
<li><a class="reference internal" href="#event-dispatcher-shortcuts-ru">Сокращения диспетчера</a></li>
<li><a class="reference internal" href="#event-dispatcher-event-name-introspection-ru">Интроспекция имени события</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">Другие диспетчеры</a></li>
<li><a class="reference internal" href="#id18">Узнайте больше</a></li>
</ul>
</li>
</ul>

    </div>
</div>
                
            </div>

            <div class="ads m-b-30">
                <h2>Вакансии Playtini</h2>
                <div class="ad m-b-15">
                    <h3>
                        <a href="http://playtini.ua/careers/php-dev">
                            Middle+ PHP Developer/Symfony
                        </a>
                    </h3>
                    <div><b>Playtini</b> активно поддерживает и развивает свои продукты, и профессионализм команды. И на данный момент в поиске специалиста на позицию <b>«Middle+ PHP Developer/Symfony»,</b> который улучшит качество внутренних сервисов компании и увеличит их количество.</div>
                </div>
                <!--
                <div class="ad m-b-15">
                    <h3>
                        <a href="http://playtini.ua/careers/symfony-senior">
                            Senior PHP Developer/Symfony
                        </a>
                    </h3>
                    <div>We are looking for strong, experienced <b>Senior PHP Developer/Symfony.</b> We expect him/her to participate in improving and extending a system built using microservice architecture by means of modern technologies.</div>
                </div>
                -->
                <div class="ad">
                    <h3><a href="http://playtini.ua/careers">
                        Остальные вакансии компании
                        <img src="..\..\..\_images\logo-playtini.png" alt="Playtini">
                    </a></h3>
                </div>
            </div>
        </div>

        <div id="main" class="col-sm-9">
            <ol class="breadcrumb">
                
                <li><a href="..\index.html">Документация</a></li>
                
                <li><a href="index.html">The Components</a></li>
                
                <li class="active">Компонент EventDispatcher</li>
            </ol>

            <div class="page">
                
  <div class="section" id="eventdispatcher">
<span id="index-0"></span><h1>Компонент EventDispatcher<a class="headerlink" href="#eventdispatcher" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>Компонент EventDispatcher предоставляет инструменты, которые позволяют
компонентам вашего приложения общаться друг с другом, запуская события
и слушая их.</div></blockquote>
<div class="section" id="id1">
<h2>Вступление<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Объектно-ориентированный код прошёл длинный путь, чтобы гарантировать
расширяемость кода. Создавая классы, которые имеют чётко определённые
задачи, вы делаетеваш код более гибким, и разработчик может расширять
их с помощью подклассов для настройки этого поведения. Но если они хотят
поделиться изменениями с другими разработчиками, которые также создали
свои собственные подклассы, наследование кода больше не является решением.</p>
<p>Представьте реальный пример, где вы хотите предоставить систему плагинов
для вашего проекта. Плагин должен иметь возможность добавлять методы или
делать что-то до или после того, как выполняется метод, не вмешиваясь в
работу других плагинов. Это непростая задачка для одного только наследования,
и даже если бы множественное наследование было возможно в PHP, оно имеет
свои недостатки</p>
<p>Компонент Symfony EventDispatcher реализует шаблоны проектирования <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Mediator</a> and <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Observer</a>
для того, чтобы сделать всё это возможным и предоставить вашим проектам
быть действительно расширяемыми.</p>
<p>Возьмите простой пример из <a class="reference internal" href="http_kernel.html"><em>компонента HttpKernel</em></a>.
Когда объект <tt class="docutils literal"><code>Response</code></tt> уже создан, может быть ползеным позволить другим элементам
в системе изменять его (например, добавлять некоторые кеш-заголовки) до его реального
использования. Чтобы сделать это возможным, Ядро Symfony вызывает событие - <tt class="docutils literal"><code>kernel.response</code></tt>.
Вот, как оно работает:</p>
<ul class="simple">
<li><em>Слушатель</em> (PHP-объект) сообщает центральному объекту <em>диспетчеру</em>, что он
хочет слушать событие <tt class="docutils literal"><code>kernel.response</code></tt>;</li>
<li>В какой-то момент, ядро Symfony сообзщает объекту <em>диспетчеру</em> запустить
событие <tt class="docutils literal"><code>kernel.response</code></tt>, передавая его с объектом <tt class="docutils literal"><code>Event</code></tt>, который
имеет доступ к объекту <tt class="docutils literal"><code>Response</code></tt>;</li>
<li>Диспетчер уведомляет (т.е. вызывает метод) всех слушателей события
<tt class="docutils literal"><code>kernel.response</code></tt>, позволяя каждому из них делать изменения в объекте
<tt class="docutils literal"><code>Response</code></tt>.</li>
</ul>
</div>
<div class="section" id="index-1">
<span id="id2"></span><h2>Установка<a class="headerlink" href="#index-1" title="Permalink to this headline">¶</a></h2>
<div class="literal-block"><div class="highlight-terminal"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require symfony/event-dispatcher
</pre></div>
</td></tr></table></div></div>
<p>Также вы можете клонировать репозиторий <a class="reference external" href="https://github.com/symfony/event-dispatcher">https://github.com/symfony/event-dispatcher</a>.</p>
<div class="admonition-wrapper">
<div class="note"></div><div class="admonition admonition-note"><p class="first admonition-title">Note</p>
<p class="last">If you install this component outside of a Symfony application, you must
require the <tt class="docutils literal"><code>vendor/autoload.php</code></tt> file in your code to enable the class
autoloading mechanism provided by Composer. Read
<a class="reference internal" href="using_components.html"><em>this article</em></a> for more details.</p>
</div></div>
</div>
<div class="section" id="id3">
<h2>Применение<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="admonition-wrapper">
<div class="seealso"></div><div class="admonition admonition-seealso">Эта статья объясняет как использовать функции EventDispatcher как независимого
компонента в любом приложении PHP. Прочитайте статью <a class="reference internal" href="..\event_dispatcher.html"><em>Events and Event Listeners</em></a>
для понимания как использовать его в приложениях Symfony.</div></div>
<div class="section" id="id4">
<h3>События<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Когда развёртывается событие, оно определяется уникальным именем (например,
<tt class="docutils literal"><code>kernel.response</code></tt>), которое может слушать любое количество слушателей. Также
создаётся и передаётся всем слушателям экземпляр <tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/Event.html" title="Symfony\Component\EventDispatcher\Event">Event</a></code></tt>.
Как вы увидите позже, сам объект <tt class="docutils literal"><code>Event</code></tt> часто содержит данные о запускаемом
событии.</p>
<div class="section" id="index-2">
<span id="id5"></span><h4>Соглашения именования<a class="headerlink" href="#index-2" title="Permalink to this headline">¶</a></h4>
<p>Уникальное имя события может быть любой строкой, но по желанию следуйте нескольким
простым соглашениям именования:</p>
<ul class="simple">
<li>Используйте только строчные буквы, цифры, точки (<tt class="docutils literal"><code>.</code></tt>) и нижние подчёркивания (<tt class="docutils literal"><code>_</code></tt>);</li>
<li>Добавляйте к именам префикс пространства имён с точкой (например, <tt class="docutils literal"><code>order.</code></tt>, <tt class="docutils literal"><code>user.*</code></tt>);</li>
<li>Заканчивайте имена глаголом, который обозначает, какое действие было выполнено (например,
<tt class="docutils literal"><code>order.placed</code></tt>).</li>
</ul>
</div>
<div class="section" id="index-3">
<span id="id6"></span><h4>Именя и объекты событий<a class="headerlink" href="#index-3" title="Permalink to this headline">¶</a></h4>
<p>Когда диспетчер уведомляет слушателей, он передаёт настоящий объект <tt class="docutils literal"><code>Event</code></tt>
этим слушателям. Базовый класс <tt class="docutils literal"><code>Event</code></tt> очень прост: он содержит метод для
остановки <a class="reference internal" href="event_dispatcher.html#event-dispatcher-event-propagation"><span>распространения события</span></a>,
и больше ничего.</p>
<div class="admonition-wrapper">
<div class="seealso"></div><div class="admonition admonition-seealso">Прочтите &quot;<a class="reference internal" href="event_dispatcher\generic_event.html"><em>The Generic Event Object</em></a>&quot;, чтобы узнать
больше об этом объекте базового события.</div></div>
<p>Зачастую, данные о конкретном событии должны быть переданы вместе с объектом
<tt class="docutils literal"><code>Event</code></tt>, чтобы слушатели имели необходимую им информацию. В таком случае,
можно передать специальный подкласс, который имеет дополнительные методы для
извлечения и переопределения информации, при запуске события. Например, событие
<tt class="docutils literal"><code>kernel.response</code></tt> использует <tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/FilterResponseEvent.html" title="Symfony\Component\HttpKernel\Event\FilterResponseEvent">FilterResponseEvent</a></code></tt>,
который содержит методы, чтобы получать и даже заменять объект <tt class="docutils literal"><code>Response</code></tt>.</p>
</div>
</div>
<div class="section" id="id7">
<h3>Диспетчер<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Диспетчер - это центральный объект системы запуска событий. Обычно создаётся
один диспетчер, который содержит реестр слушателей. Когда событие запускается
через диспетчер, он уведомляет всех слушателей, зарегистрированных с этим событием:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventDispatcher</span><span class="p">;</span>

<span class="nv">$dispatcher</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventDispatcher</span><span class="p">();</span>
</pre></div>
</td></tr></table></div></div>
</div>
<div class="section" id="index-4">
<span id="id8"></span><h3>Соединение слушателей<a class="headerlink" href="#index-4" title="Permalink to this headline">¶</a></h3>
<p>Чтобы воспользоваться преимуществами существующего события, вам нужно соединить
слушателя с диспетчером, чтобы он мог быть уведомлён, когда событие будет запущено.
Вызов метода диспетчера <tt class="docutils literal"><code>addListener()</code></tt> ассоциирует все вызываемые PHP с событием:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nv">$listener</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AcmeListener</span><span class="p">();</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">addListener</span><span class="p">(</span><span class="s1">&#39;acme.foo.action&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="nv">$listener</span><span class="p">,</span> <span class="s1">&#39;onFooAction&#39;</span><span class="p">));</span>
</pre></div>
</td></tr></table></div></div>
<p>Метод <tt class="docutils literal"><code>addListener()</code></tt> имеет до трёх аргументов:</p>
<ol class="arabic simple">
<li>Имя события (строка), которое хочет слушать этот слушатель;</li>
<li>Вызываемое PHP, которое будет выполнено при запуске указанного события;</li>
<li>Необязательное число приоритета (чем выше - тем важнее, следовательно
этот слушатель будет запущен раньше), которое определяет, когда вызывается
слушатель по отношению к другим слушателям (по умолчанию <tt class="docutils literal"><code>0</code></tt>). Если два
слушателя имеют одинаковый приоритет, они выполняются в том порядке, в котором
были добавлены в диспетчер.</li>
</ol>
<div class="admonition-wrapper">
<div class="note"></div><div class="admonition admonition-note"><p class="first admonition-title">Note</p>
<p><a class="reference external" href="https://php.net/manual/en/language.pseudo-types.php#language.types.callback">PHP вызываемое</a> - это переменная PHP, которая может быть использована
функцией <tt class="docutils literal"><code>call_user_func()</code></tt> и возвращает <tt class="docutils literal"><code>true</code></tt> при передаче функции
<tt class="docutils literal"><code>is_callable()</code></tt>. Это может быть экземпляр <tt class="docutils literal"><code>\Closure</code></tt>, объект, реализующий
метод <tt class="docutils literal"><code>__invoke()</code></tt> (то, чем на самом деле являются замыкания), строка,
представляющая функцию или массив, представляющий метод объекта или класса.</p>
<p>До этих пор вы видели, как можно зарегистрировать PHP объекты в качестве
слушателей. Вы можете также зарегистрировать PHP <a class="reference external" href="https://php.net/manual/en/functions.anonymous.php">Замыкания</a> в качестве
слушателей событий:</p>
<div class="literal-block"><div class="last highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\Event</span><span class="p">;</span>

<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">addListener</span><span class="p">(</span><span class="s1">&#39;acme.foo.action&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">Event</span> <span class="nv">$event</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// будет выполнено при запуске события acme.foo.action</span>
<span class="p">});</span>
</pre></div>
</td></tr></table></div></div>
</div></div>
<p>Когда слушатель зарегистрирован в диспетчере, он ждёт, пока не будет уведомления
о событии. В примере выше, когда запускается событие <tt class="docutils literal"><code>acme.foo.action</code></tt>,  диспетчер
вызывает метод <tt class="docutils literal"><code>AcmeListener::onFooAction()</code></tt> и передаёт объект <tt class="docutils literal"><code>Event</code></tt> в виде
единственного аргумента:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\Event</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AcmeListener</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onFooAction</span><span class="p">(</span><span class="nx">Event</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ... сделать что-то</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Аргумент <tt class="docutils literal"><code>$event</code></tt> - это объект события, который был передан при запуске
события. Во многих случаях, передаётся специальный подкласс события с
дополнительной информацией. Вы можете посмотреть документацию или реализацию
каждого событий, чтобы определить, какой экземпляр передаётся.</p>
<div class="admonition-wrapper">
<div class="sidebar"></div><div class="admonition admonition-sidebar"><p class="first sidebar-title">Регистрация слушателей событий и подписчиков в сервис-контейнере</p>
<p>Регистрации определений сервисов и тегирования их тегами
<tt class="docutils literal"><code>kernel.event_listener</code></tt> и <tt class="docutils literal"><code>kernel.event_subscriber</code></tt> недостаточно для того,
чтобы включить слушателей и подписчиков событий. Вы также должны зарегистрировать
пропуск компилировщика под названием <tt class="docutils literal"><code>RegisterListenersPass()</code></tt> в конструкторе контейнера:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ParameterBag\ParameterBag</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Reference</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventDispatcher</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass</span><span class="p">;</span>

<span class="nv">$containerBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">(</span><span class="k">new</span> <span class="nx">ParameterBag</span><span class="p">());</span>
<span class="c1">// регистрирует пропуск компилировщика, который обрабатывает теги сервиса</span>
<span class="c1">// &#39;kernel.event_listener&#39; и &#39;kernel.event_subscriber&#39;</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">addCompilerPass</span><span class="p">(</span><span class="k">new</span> <span class="nx">RegisterListenersPass</span><span class="p">());</span>

<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;event_dispatcher&#39;</span><span class="p">,</span> <span class="nx">EventDispatcher</span><span class="o">::</span><span class="na">class</span><span class="p">);</span>

<span class="c1">// регистрирует слушателя события</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;listener_service_id&#39;</span><span class="p">,</span> <span class="nx">\AcmeListener</span><span class="o">::</span><span class="na">class</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">addTag</span><span class="p">(</span><span class="s1">&#39;kernel.event_listener&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;event&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;acme.foo.action&#39;</span><span class="p">,</span>
        <span class="s1">&#39;method&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;onFooAction&#39;</span><span class="p">,</span>
    <span class="p">));</span>

<span class="c1">// регистрирует подписчика событий</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;subscriber_service_id&#39;</span><span class="p">,</span> <span class="nx">\AcmeSubscriber</span><span class="o">::</span><span class="na">class</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">addTag</span><span class="p">(</span><span class="s1">&#39;kernel.event_subscriber&#39;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div></div>
<p class="last">По умолчанию, пропуск слушателей предполагает, что id сервиса диспетчера событий
- <tt class="docutils literal"><code>event_dispatcher</code></tt>, что слушатели событий тегированы тегом <tt class="docutils literal"><code>kernel.event_listener</code></tt>,
и что подписчики событий тегированы тегом <tt class="docutils literal"><code>kernel.event_subscriber</code></tt>. Вы можете
изменить эти значения по умолчанию, передав пользовательские значения конструктору
<tt class="docutils literal"><code>RegisterListenersPass</code></tt>.</p>
</div></div>
<span class="target" id="event-dispatcher-closures-as-listeners-ru"></span></div>
<div class="section" id="index-5">
<span id="id9"></span><h3>Создание и запуск события<a class="headerlink" href="#index-5" title="Permalink to this headline">¶</a></h3>
<p>Кроме регистрации в слушателях существующих событий, вы можете создавать
и запускать собственные события. Это полезно при создании сторонних библиотек,
а также,когда вы хотите сохранять разные компоненты вашей собственной системы
гибкими и разделёнными.</p>
<div class="section" id="creating-an-event-object-ru">
<span id="id10"></span><h4>Создание класса событий<a class="headerlink" href="#creating-an-event-object-ru" title="Permalink to this headline">¶</a></h4>
<p>Представьте, что вы хотите создать новое событие - <tt class="docutils literal"><code>order.placed</code></tt> - которое
запускается каждый раз, когда пользователь заказывает товар в вашем приложении.
При запуске этого события, вы передаёте пользовательский экземпляр события,
который имеет доступ к размещённому заказу. Начните с создания этого пользоватсклього
класса события и его документирования:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nx">Acme\Store\Event</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\Event</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Acme\Store\Order</span><span class="p">;</span>

<span class="sd">/**</span>
<span class="sd"> * Событие order.placed запускается каждый раз, когда создаётся заказ</span>
<span class="sd"> * в системе.</span>
<span class="sd"> */</span>
<span class="k">class</span> <span class="nc">OrderPlacedEvent</span> <span class="k">extends</span> <span class="nx">Event</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="no">NAME</span> <span class="o">=</span> <span class="s1">&#39;order.placed&#39;</span><span class="p">;</span>

    <span class="k">protected</span> <span class="nv">$order</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">Order</span> <span class="nv">$order</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">order</span> <span class="o">=</span> <span class="nv">$order</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getOrder</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">order</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Каждый слушатель теперь имеет доступ к заказу через метод <tt class="docutils literal"><code>getOrder()</code></tt>.</p>
<div class="admonition-wrapper">
<div class="note"></div><div class="admonition admonition-note"><p class="first admonition-title">Note</p>
<p class="last">Если вам не нужно передавать никаких дополнительных данных слушателям событий,
то вы также можете использовать класс по умолчанию
<tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/Event.html" title="Symfony\Component\EventDispatcher\Event">Event</a></code></tt>. В таком случае, вы можете
документировать событие иего имя в общем классе <tt class="docutils literal"><code>StoreEvents</code></tt>, схожим с классом
<tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/KernelEvents.html" title="Symfony\Component\HttpKernel\KernelEvents">KernelEvents</a></code></tt>.</p>
</div></div>
</div>
<div class="section" id="id11">
<h4>Запустите событие<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>Метод <tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/EventDispatcher.html#method_dispatch" title="Symfony\Component\EventDispatcher\EventDispatcher::dispatch()">dispatch()</a></code></tt>
уведомляет всех слушателей о данном событии. Используется два аргумента: имя
события для запуска, и экземпляр <tt class="docutils literal"><code>Event</code></tt> для передачи каждому слушателю этого
события:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Acme\Store\Order</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Acme\Store\Event\OrderPlacedEvent</span><span class="p">;</span>

<span class="c1">// создаёт или извлекает порядок каким-либо образом</span>
<span class="nv">$order</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Order</span><span class="p">();</span>
<span class="c1">// ...</span>

<span class="c1">// создаёт OrderPlacedEvent и запускает его</span>
<span class="nv">$event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OrderPlacedEvent</span><span class="p">(</span><span class="nv">$order</span><span class="p">);</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="nx">OrderPlacedEvent</span><span class="o">::</span><span class="na">NAME</span><span class="p">,</span> <span class="nv">$event</span><span class="p">);</span>
</pre></div>
</td></tr></table></div></div>
<p>Заметьте, что специальный объект <tt class="docutils literal"><code>OrderPlacedEvent</code></tt> создаётся и передаётся
методу <tt class="docutils literal"><code>dispatch()</code></tt>. Теперь, любой слушатель события <tt class="docutils literal"><code>order.placed</code></tt> получит
<tt class="docutils literal"><code>OrderPlacedEvent</code></tt>.</p>
</div>
</div>
<div class="section" id="event-dispatcher-using-event-subscribers-ru">
<span id="index-6"></span><span id="id12"></span><h3>Использование подписчиков событий<a class="headerlink" href="#event-dispatcher-using-event-subscribers-ru" title="Permalink to this headline">¶</a></h3>
<p>Наиболее распротранённый способ слушать событие - зарегистрировать в диспетчере
<em>слушатель событий</em>. Этот слушатель может слушать одно или более событий и уведомляется
каждый раз, когда запускаются эти события.</p>
<p>Другим способом слушать события является через <em>подписчика событий</em>. Подписчик
событий - это PHP класс, который способен сообщить диспетчеру, на какие именно
события ему нужно подпистаься. Он реализует интерфейс
<tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/EventSubscriberInterface.html" title="Symfony\Component\EventDispatcher\EventSubscriberInterface">EventSubscriberInterface</a></code></tt>, который
требует одного статичного метода, под названием
<tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/EventSubscriberInterface.html#method_getSubscribedEvents" title="Symfony\Component\EventDispatcher\EventSubscriberInterface::getSubscribedEvents()">getSubscribedEvents()</a></code></tt>.
Возьмите следующий пример подписчика, который подписывается на события
<tt class="docutils literal"><code>kernel.response</code></tt> и <tt class="docutils literal"><code>order.placed</code></tt>:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nx">Acme\Store\Event</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventSubscriberInterface</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpKernel\Event\FilterResponseEvent</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpKernel\KernelEvents</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Acme\Store\Event\OrderPlacedEvent</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">StoreSubscriber</span> <span class="k">implements</span> <span class="nx">EventSubscriberInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getSubscribedEvents</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">array</span><span class="p">(</span>
            <span class="nx">KernelEvents</span><span class="o">::</span><span class="na">RESPONSE</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
                <span class="k">array</span><span class="p">(</span><span class="s1">&#39;onKernelResponsePre&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="k">array</span><span class="p">(</span><span class="s1">&#39;onKernelResponsePost&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="nx">OrderPlacedEvent</span><span class="o">::</span><span class="na">NAME</span> <span class="o">=&gt;</span> <span class="s1">&#39;onStoreOrder&#39;</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onKernelResponsePre</span><span class="p">(</span><span class="nx">FilterResponseEvent</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onKernelResponsePost</span><span class="p">(</span><span class="nx">FilterResponseEvent</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onStoreOrder</span><span class="p">(</span><span class="nx">OrderPlacedEvent</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Это очень похоже на класс слушателя, кроме того, что сам классможет сказать
диспетчеру, какие события ему стоит слушать. Чтобы зарегистрирвать подписчика
в диспетчере, используйте метод
<tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/EventDispatcher.html#method_addSubscriber" title="Symfony\Component\EventDispatcher\EventDispatcher::addSubscriber()">addSubscriber()</a></code></tt>:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Acme\Store\Event\StoreSubscriber</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="nv">$subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreSubscriber</span><span class="p">();</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">addSubscriber</span><span class="p">(</span><span class="nv">$subscriber</span><span class="p">);</span>
</pre></div>
</td></tr></table></div></div>
<p>Диспетчер автоматически зарегистрирует подписчика для каждого события, возвращённого
методом <tt class="docutils literal"><code>getSubscribedEvents()</code></tt>. Этот метод возвращает массив, индексированный по
именам событий, значения которых являются либо именем метода для вызова, либо массивом,
составленным из именим метода для вызова и приоритетом. Вышеописанный пример демонстрирует,
как зарегистрировать несколько методов слушателя для одного и того же события в подписчике,
а также, как передать приоритет каждого метода слушателя. Чем выше приоритет, тем раньше
вызывается метод. В вышеописанном примере, когда запускается событие <tt class="docutils literal"><code>kernel.response</code></tt>,
вызываются методы <tt class="docutils literal"><code>onKernelResponsePre()</code></tt> и <tt class="docutils literal"><code>onKernelResponsePost()</code></tt> в таком порядке.</p>
</div>
<div class="section" id="event-dispatcher-event-propagation-ru">
<span id="index-7"></span><span id="id13"></span><h3>Остановка потока / распространения событий<a class="headerlink" href="#event-dispatcher-event-propagation-ru" title="Permalink to this headline">¶</a></h3>
<p>В некоторых случаях, слушателю имеет смысл предотвращать вызов любых слушателей.
Другими словами, слушателю нужно иметь возможность сказать диспетчеру прекратить
расространене события в будущие слушатели (т.е. более не уведомлять слушателей).
Это можно сделать изнутри слушателя,с помощью метода
<tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/Event.html#method_stopPropagation" title="Symfony\Component\EventDispatcher\Event::stopPropagation()">stopPropagation()</a></code></tt>:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Acme\Store\Event\OrderPlacedEvent</span><span class="p">;</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">onStoreOrder</span><span class="p">(</span><span class="nx">OrderPlacedEvent</span> <span class="nv">$event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="nv">$event</span><span class="o">-&gt;</span><span class="na">stopPropagation</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Теперь, любые слушатели <tt class="docutils literal"><code>order.placed</code></tt>, которые ещё не были вызваны, <em>не</em>
будут вызваны.</p>
<p>Возможно определить, было ли событие остановлено с использованием метода
<tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/Event.html#method_isPropagationStopped" title="Symfony\Component\EventDispatcher\Event::isPropagationStopped()">isPropagationStopped()</a></code></tt>,
который возвращает булево значение:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="s1">&#39;foo.event&#39;</span><span class="p">,</span> <span class="nv">$event</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="na">isPropagationStopped</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
</div>
<div class="section" id="event-dispatcher-dispatcher-aware-events-ru">
<span id="index-8"></span><span id="id14"></span><h3>События и слушатели, знающие об EventDispatcher<a class="headerlink" href="#event-dispatcher-dispatcher-aware-events-ru" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><code>EventDispatcher</code></tt> всегда передаёт запущенное событие, имя события и ссылку на себя
самого слушателям. Это может привести к некоторым продвинутым применениям <tt class="docutils literal"><code>EventDispatcher</code></tt>,
включая запуск других событий внутри слушателей, связывание событий или даже ленивую
загрузку слушателей в объекте диспетчера.</p>
</div>
<div class="section" id="event-dispatcher-shortcuts-ru">
<span id="index-9"></span><span id="id15"></span><h3>Сокращения диспетчера<a class="headerlink" href="#event-dispatcher-shortcuts-ru" title="Permalink to this headline">¶</a></h3>
<p>Если вам не нужен пользовательский объект событий, вы можете просто положиться
на обычный объект <tt class="docutils literal"><code><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/EventDispatcher/Event.html" title="Symfony\Component\EventDispatcher\Event">Event</a></code></tt>. Вам даже
не нужно передавать его диспетчеру, так как он будет создан по умолчанию, кроме
случаев, когда вы специально его передадите:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="s1">&#39;order.placed&#39;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div></div>
<p>Более того, диспетчер событий всегда возвращает тот объект события, который
был запущен, т.е. либо событие, которое было передано, либо событие, которое
было создано внутренне диспетчером. Это позволяет использовать крутые сокращения:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="s1">&#39;foo.event&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">isPropagationStopped</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Или:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nv">$event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OrderPlacedEvent</span><span class="p">(</span><span class="nv">$order</span><span class="p">);</span>
<span class="nv">$order</span> <span class="o">=</span> <span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="s1">&#39;bar.event&#39;</span><span class="p">,</span> <span class="nv">$event</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">getOrder</span><span class="p">();</span>
</pre></div>
</td></tr></table></div></div>
<p>и так далее.</p>
</div>
<div class="section" id="event-dispatcher-event-name-introspection-ru">
<span id="index-10"></span><span id="id16"></span><h3>Интроспекция имени события<a class="headerlink" href="#event-dispatcher-event-name-introspection-ru" title="Permalink to this headline">¶</a></h3>
<p>Экземпляр <tt class="docutils literal"><code>EventDispatcher</code></tt>, так же как и имя события, которое запускается,
передаются в качестве аргументов слушателя:</p>
<div class="literal-block"><div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\Event</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventDispatcherInterface</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">myEventListener</span><span class="p">(</span><span class="nx">Event</span> <span class="nv">$event</span><span class="p">,</span> <span class="nv">$eventName</span><span class="p">,</span> <span class="nx">EventDispatcherInterface</span> <span class="nv">$dispatcher</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ... сделать что-то с именем события</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
</div>
</div>
<div class="section" id="id17">
<h2>Другие диспетчеры<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>Кроме распространённого <tt class="docutils literal"><code>EventDispatcher</code></tt>, компонент поставляется с некоторыми
другими диспетчерами:</p>
<ul class="simple">
<li><a class="reference internal" href="event_dispatcher\container_aware_dispatcher.html"><em>The Container Aware Event Dispatcher</em></a></li>
<li><a class="reference internal" href="event_dispatcher\immutable_dispatcher.html"><em>The Immutable Event Dispatcher</em></a></li>
<li><a class="reference internal" href="event_dispatcher\traceable_dispatcher.html"><em>The Traceable Event Dispatcher</em></a></li>
</ul>
</div>
<div class="section" id="id18">
<h2>Узнайте больше<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher\container_aware_dispatcher.html">The Container Aware Event Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/container_aware_dispatcher-ru.html">Диспетчер событий, распознающий контейнер</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher\generic_event.html">The Generic Event Object</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/generic_event-ru.html">Объект Generic Event (событие общего назначения)</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher\immutable_dispatcher.html">The Immutable Event Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/immutable_dispatcher-ru.html">Неизменяемый диспетчер событий</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher\traceable_dispatcher.html">The Traceable Event Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/traceable_dispatcher-ru.html">Прослеживаемый диспетчер событий</a></li>
<li class="toctree-l1"><a class="reference internal" href="..\event_dispatcher\before_after_filters.html">How to Set Up Before and After Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../event_dispatcher/before_after_filters-ru.html">Как настроить фильтры &quot;до&quot; и &quot;после&quot;</a></li>
<li class="toctree-l1"><a class="reference internal" href="..\event_dispatcher\method_behavior.html">How to Customize a Method Behavior without Using Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../event_dispatcher/method_behavior-ru.html">Как настроить поведение метода, не используя наследование</a></li>
</ul>
</div>
<ul class="simple">
<li><a class="reference internal" href="..\reference\dic_tags.html#dic-tags-kernel-event-listener"><span>Тег kernel.event_listener</span></a></li>
<li><a class="reference internal" href="..\reference\dic_tags.html#dic-tags-kernel-event-subscriber"><span>Тег kernel.event_subscriber</span></a></li>
</ul>
</div>
</div>


            </div>

            
            <div class="navigation">
                <a href="../event_dispatcher/method_behavior-ru.html">« Как настроить поведение метода, не используя наследование</a>
                <span class="separator">|</span>
                <a href="expression_language.html">The ExpressionLanguage Component »</a>
            </div>
            

            <div id="license">
                <p>Эта документация является переводом <a href="http://symfony.com/doc/current/index.html">официальной документации Symfony</a> и предоставляется по свободной лицензии <a rel="license nofollow" href="https://creativecommons.org/licenses/by-sa/3.0/deed.ru">CC BY-SA 3.0</a>.</p>
            </div>
        </div>
    </div>
</div></div>


  </body>
</body></html>